# Protecting Data from Tampering

<div align="left">
  <a title="English" href="README.md">English</a>
  <a title="中文" href="README.zh-CN.md">中文</a>
</div>

<a href="https://edgeone.ai/developer/examples/protecting-data-from-tampering" style="display: inline-block; background-color: #0366d6; color: white; padding: 8px 16px; text-decoration: none; border-radius: 4px; font-weight: bold;">View Online Example</a>

This example demonstrates how to use an Edge Function to verify the integrity of response content, preventing data tampering during transmission. In this example, an SHA-256 signature is calculated for a request body and compared with the signature that is generated by the origin server. If the signatures are the same, the response content is not tampered with. Otherwise, a 416 status code is returned, indicating that the response content is tampered with. This technique ensures data security by comparing a real-time calculated signature with a signature provided by the origin server.

## How It Works

1. Define supported file types (text and image).
2. Create a function to convert Uint8Array to hexadecimal string.
3. Implement a `checkAndResponse` function that:
   - Retrieves the response content.
   - Calculates a hash of the content using a specified algorithm (e.g., SHA-256).
   - Compares the calculated hash with the hash provided by the origin server.
   - Returns the original response if hashes match, or a 416 status code if they don't.
4. Call `checkAndResponse` in the main handler function to validate each response.

## Sample Preview

The signature that is calculated by the Edge Function is the same as the signature that is provided by the origin server:

![protecting-data-from-tampering Preview](../assets/images/protecting-data-from-tampering-same.avif)

The signature that is calculated by the Edge Function is different from the signature that is provided by the origin server, and a 416 status code is returned:

![protecting-data-from-tampering-diff Preview](../assets/images/protecting-data-from-tampering-diff.avif)

## Use Cases

This technique is particularly useful in the following situations:

- Protecting the integrity of sensitive documents or data.
- Ensuring downloaded software or update packages haven't been tampered with.
- Verifying the authenticity of API responses.
- Ensuring the integrity of cached content in Content Delivery Networks (CDNs).

## Considerations

- Ensure the origin server uses secure methods to generate and store hash values.
- Choose appropriate hash algorithms (e.g., SHA-256) to provide adequate security.
- Consider the performance impact of hash verification, especially for large files.
- Make sure that the origin server uses the same signature algorithm and tamper-proofing rules that are used in this example.
- To use the tamper-proofing rules described in this example in the production environment, perform sorting on the calculated signature to prevent the signature from being cracked by attackers.

By implementing data integrity checks at the edge, you can add an extra layer of security to prevent malicious tampering of data in transit, enhancing the overall security of your application.